1. enable OTG on Raspberry pi 4B
echo "dtoverlay=dwc2" | sudo tee -a /boot/config.txt
echo "dwc2" | sudo tee -a /etc/modules

from https://github.com/girst/sendHID-mirror-of-git.gir.st/blob/master/README.md

2. enable libcomposite driver
sudo echo "libcomposite" | sudo tee -a /etc/modules

from http://www.isticktoit.net/?p=1383

3.
sudo touch /usr/bin/tabletjoyusb #create the file
sudo chmod +x /usr/bin/tabletjoyusb #make it executable

info from http://www.isticktoit.net/?p=1383
or
from https://github.com/milador/RaspberryPi-Joystick

4. make HID config autoexecutable
sudo nano /etc/rc.local #open this file
/usr/bin/tabletjoyusb # add before "exit 0"; XAC libcomposite configuration
*you can create a systemd unit file for better performance??

5.1 Made descriptor for 5th step. These helped:
http://who-t.blogspot.com/2018/12/understanding-hid-report-descriptors.html
https://eleccelerator.com/tutorial-about-usb-hid-report-descriptors/

5.2 Edit the file (sudo nano /usr/bin/tabletjoyusb), mostly from https://github.com/milador/RaspberryPi-Joystick :

#!/bin/bash

sleep 10

modprobe libcomposite


# Create joystick gadget
cd /sys/kernel/config/usb_gadget/
mkdir -p tabletjoyusb
cd tabletjoyusb

sudo su

# Define USB specification
echo 0x1d6b > idVendor # Linux Foundation
echo 0x0104 > idProduct # Multifunction Composite Joystick Gadget
echo 0x0100 > bcdDevice # v1.0.0
echo 0x0200 > bcdUSB # USB2
echo 0xEF > bDeviceClass
echo 0x02 > bDeviceSubClass
echo 0x01 > bDeviceProtocol

# Perform localization
mkdir -p strings/0x409

echo "0123456789" > strings/0x409/serialnumber
echo "Raspberry Pi" > strings/0x409/manufacturer
echo "tabletjoy" > strings/0x409/product


# Define the functions of the device
mkdir functions/hid.usb0
echo 0 > functions/hid.usb0/protocol
echo 0 > functions/hid.usb0/subclass
echo 14  > functions/hid.usb0/report_length

# Write report descriptor ( 6  analog joysticks plus 16 buttons )
echo "05010905A101A100050919012910150025019510750181020501093009310932093309340935150027FFFF0000751095068102C0C0" | xxd -r -ps > functions/hid.usb0/report_desc

# Create configuration file
mkdir configs/c.1
mkdir configs/c.1/strings/0x409

echo 0x80 > configs/c.1/bmAttributes
echo 200 > configs/c.1/MaxPower # 200 mA
echo "USBtabletjoystick configuration" > configs/c.1/strings/0x409/configuration

# Link the configuration file
ln -s functions/hid.usb0 configs/c.1

# Activate device 
ls /sys/class/udc > UDC

sleep 10

6. pip3 install evdev, module for reading tablets events
https://python-evdev.readthedocs.io/en/latest/tutorial.html

7. Write python script for data reading from 2 usbs and generating reports for gamepad/joystick device emulation (usb to windows PC).

import asyncio, evdev

def write_report(report):
    with open('/dev/hidg0', 'rb+') as fd:
        fd.write(report)

def clean_up():
    write_report(bytes(14))
    
def bv(byv,bir): #byte value, bit number (1-8). Returns bit state (1/0)
    return(byv%(2**(bir))//(2**(bir-1)))
    
def changeReport(rar,LRv,Lpen,Lpad,ecode,evalue):
    #print(ecode, evalue, sep=' ')
    
    if (LRv == Lpad or LRv == Lpen):
        i=0 #left tablet
    else:
        i=1 #right tablet
    if (ecode==0):
        [rar[3+4*i],rar[2+4*i]]=divmod(round(evalue*65535/33020),256)
        #print(rar[3+4*i],rar[2+4*i])
        #print(evalue)
    elif (ecode==1):
        [rar[5+4*i],rar[4+4*i]]=divmod(round(evalue*65535/20320),256)
    elif (ecode==256): #1
        if(evalue==1 and bv(rar[i],1)==0):
            rar[i]+=1
        elif(evalue==0 and bv(rar[i],1)==1):
            rar[i]-=1
    elif (ecode==257): #2
        if(evalue==1 and bv(rar[i],2)==0):
            rar[i]+=2
        elif(evalue==0 and bv(rar[i],2)==1):
            rar[i]-=2
    elif (ecode==258): #3
        if(evalue==1 and bv(rar[i],3)==0):
            rar[i]+=4
        elif(evalue==0 and bv(rar[i],3)==1):
            rar[i]-=4
    elif (ecode==259): #4
        if(evalue==1 and bv(rar[i],4)==0):
            rar[i]+=8
        elif(evalue==0 and bv(rar[i],4)==1):
            rar[i]-=8
    elif (ecode==331): #5
        if(evalue==1 and bv(rar[i],5)==0):
            rar[i]+=16
        elif(evalue==0 and bv(rar[i],5)==1):
            rar[i]-=16
    elif (ecode==332): #6
        if(evalue==1 and bv(rar[i],6)==0):
            rar[i]+=32
        elif(evalue==0 and bv(rar[i],6)==1):
            rar[i]-=32
    elif (ecode==320): #7
        if(evalue==1 and bv(rar[i],7)==0):
            rar[i]+=64
        elif(evalue==0 and bv(rar[i],7)==1):
            rar[i]-=64
    elif (ecode==330): #8
        if(evalue==1 and bv(rar[i],8)==0):
            rar[i]+=128
        elif(evalue==0 and bv(rar[i],8)==1):
            rar[i]-=128
    return rar

#[0][1][2][3][4][5][6][7][8][9][10][11][12][13]
# B  B  X  X  Y  Y  Z  Z  Rx Rx Ry  Ry  Rz  Rz
def main():
    #list devices
    devices = [evdev.InputDevice(path) for path in evdev.list_devices()]
    for device in devices:
        if device.phys == "usb-0000:01:00.0-1.1/input0" and device.name == "GAOMON Gaomon Tablet Pen":
            pen1 = evdev.InputDevice(device.path)
            pen1.grab()
        elif device.phys == "usb-0000:01:00.0-1.2/input0" and device.name == "GAOMON Gaomon Tablet Pen":
            pen2 = evdev.InputDevice(device.path)
            pen2.grab()
        elif device.phys == "usb-0000:01:00.0-1.1/input0" and device.name == "GAOMON Gaomon Tablet Pad":
            pad1 = evdev.InputDevice(device.path)
            pad1.grab()
        elif device.phys == "usb-0000:01:00.0-1.2/input0" and device.name == "GAOMON Gaomon Tablet Pad":
            pad2 = evdev.InputDevice(device.path)
            pad2.grab()
            
    ReportArr=bytearray(14)
    async def print_events(device,ReportArr):
        
        async for event in device.async_read_loop():
            if event.type == evdev.ecodes.EV_KEY or event.type == evdev.ecodes.EV_ABS:
                ReportArr=changeReport(ReportArr,device.fd,pen1.fd,pad1.fd,event.code,event.value)
                write_report(ReportArr)
                #print(ReportArr[0],ReportArr[1])
    for device in pen1, pad1, pen2, pad2:
        asyncio.ensure_future(print_events(device,ReportArr))
    loop = asyncio.get_event_loop()
    loop.run_forever()
    

if __name__ == "__main__":
    main()

8. Ups and downs
Good:
Works good enough when inputting separatelly from tablet 1 (pen1 and pad1) or from tablet2.
Bad:
Reports are a bit late for some events when using both tablets simultaniously with both pens
(maybe file reopening/big amounts of events/close events to each other while using separate tablets/too frequent updating/ idk, could be better...)
